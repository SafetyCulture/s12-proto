// Copyright (c) 2019 SafetyCulture Pty Ltd. All Rights Reserved.

#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/compiler/plugin.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <string>
#include <iostream>

using google::protobuf::FileDescriptor;
using google::protobuf::compiler::CodeGenerator;
using google::protobuf::compiler::GeneratorContext;
using google::protobuf::compiler::ParseGeneratorParameter;
using google::protobuf::compiler::PluginMain;
using google::protobuf::io::Printer;
using google::protobuf::io::ZeroCopyOutputStream;

namespace cppservice_generator
{
namespace
{

using std::string;

// The following 5 functions were copied from
// google/protobuf/src/google/protobuf/stubs/strutil.h

inline bool HasPrefixString(const string &str, const string &prefix)
{
  return str.size() >= prefix.size() && str.compare(0, prefix.size(), prefix) == 0;
}

inline string StripPrefixString(const string &str, const string &prefix)
{
  if (HasPrefixString(str, prefix))
  {
    return str.substr(prefix.size());
  }
  else
  {
    return str;
  }
}

inline bool HasSuffixString(const string &str, const string &suffix)
{
  return str.size() >= suffix.size() && str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
}

inline string StripSuffixString(const string &str, const string &suffix)
{
  if (HasSuffixString(str, suffix))
  {
    return str.substr(0, str.size() - suffix.size());
  }
  else
  {
    return str;
  }
}

void ReplaceCharacters(string *s, const char *remove, char replacewith)
{
  const char *str_start = s->c_str();
  const char *str = str_start;
  for (str = strpbrk(str, remove); str != nullptr; str = strpbrk(str + 1, remove))
  {
    (*s)[str - str_start] = replacewith;
  }
}

// The following function was copied from
// google/protobuf/src/google/protobuf/compiler/cpp/cpp_helpers.cc

string StripProto(const string &filename)
{
  if (HasSuffixString(filename, ".protodevel"))
  {
    return StripSuffixString(filename, ".protodevel");
  }
  else
  {
    return StripSuffixString(filename, ".proto");
  }
}

// The following function was copied from
// grpc/src/compiler/cpp_generator.cc

string FilenameIdentifier(const string &filename)
{
  string result;
  for (unsigned i = 0; i < filename.size(); i++)
  {
    char c = filename[i];
    if (isalnum(c))
    {
      result.push_back(c);
    }
    else
    {
      static char hex[] = "0123456789abcdef";
      result.push_back('_');
      result.push_back(hex[(c >> 4) & 0xf]);
      result.push_back(hex[c & 0xf]);
    }
  }
  return result;
}

// The following function was copied from
// grpc/src/compiler/generator_helpers.h
inline std::vector<string> tokenize(const string &input, const string &delimiters)
{
  std::vector<string> tokens;
  size_t pos, last_pos = 0;

  for (;;)
  {
    bool done = false;
    pos = input.find_first_of(delimiters, last_pos);
    if (pos == string::npos)
    {
      done = true;
      pos = input.length();
    }

    tokens.push_back(input.substr(last_pos, pos - last_pos));
    if (done)
      return tokens;

    last_pos = pos + 1;
  }
}

void PrintHeaderPrologue(Printer *printer, const FileDescriptor *file)
{
  std::map<string, string> vars;
  vars["filename"] = file->name();
  vars["filename_identifier"] = FilenameIdentifier(file->name());

  printer->Print(vars, "// Generated by the s12 Service Impl C++ plugin.\n");
  printer->Print(vars, "// If you make any local change, they will be lost.\n");
  printer->Print(vars, "// source: $filename$\n");
  printer->Print(vars, "#ifndef GRPC_IMPL_$filename_identifier$__INCLUDED\n");
  printer->Print(vars, "#define GRPC_IMPL_$filename_identifier$__INCLUDED\n");
  printer->Print(vars, "\n");
}

void PrintHeaderIncludes(Printer *printer, const FileDescriptor *file)
{
  std::map<string, string> vars;
  vars["filename_base"] = StripProto(file->name());

  printer->Print(vars, "#pragma once\n\n");
  printer->Print(vars, "#include \"$filename_base$.grpc.pb.h\"\n\n");
  printer->Print(vars, "#include <string>\n");
  printer->Print(vars, "#include <memory>\n\n");

  if (!file->package().empty())
  {
    std::vector<string> parts = tokenize(file->package(), ".");
    for (auto part = parts.begin(); part != parts.end(); part++)
    {
      vars["part"] = *part;
      printer->Print(vars, "namespace $part$ {\n");
    }
    printer->Print(vars, "\n");
  }
}

void PrintHeaderEpilogue(Printer *printer, const FileDescriptor *file)
{
  std::map<string, string> vars;
  vars["filename"] = file->name();
  vars["filename_identifier"] = FilenameIdentifier(file->name());

  if (!file->package().empty())
  {
    std::vector<string> parts = tokenize(file->package(), ".");

    for (auto part = parts.rbegin(); part != parts.rend(); part++)
    {
      vars["part"] = *part;
      printer->Print(vars, "}  // namespace $part$\n");
    }
    printer->Print(vars, "\n");
  }

  printer->Print(vars, "#endif  // GRPC_SERVICE_$filename_identifier$__INCLUDED\n");
}

class Generator : public CodeGenerator
{
public:
  Generator() {}
  ~Generator() override {}

  bool Generate(const FileDescriptor *file, const string &parameter, GeneratorContext *context, string *error) const override
  {
    if (!file->service_count())
    {
      // No services, nothing to do.
      return true;
    }

    string file_name = StripProto(file->name());

    std::unique_ptr<ZeroCopyOutputStream> header_output(context->Open(file_name + ".grpc.impl.pb.h"));
    Printer header_printer(header_output.get(), '$');
    PrintHeaderPrologue(&header_printer, file);
    PrintHeaderIncludes(&header_printer, file);
    PrintHeaderEpilogue(&header_printer, file);

    std::unique_ptr<ZeroCopyOutputStream> source_output(context->Open(file_name + ".grpc.impl.pb.cc"));
    Printer source_printer(source_output.get(), '$');

    return true;
  }
};

} // namespace
} // namespace cppservice_generator

int main(int argc, char *argv[])
{
  cppservice_generator::Generator generator;
  PluginMain(argc, argv, &generator);
  return 0;
}