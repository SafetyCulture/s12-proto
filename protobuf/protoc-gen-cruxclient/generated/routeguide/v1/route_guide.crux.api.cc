// Generated by the CRUX Engine C++ plugin.
// If you make any local change, they will be lost.
// source: routeguide/v1/route_guide.proto

#include "route_guide.crux.api.h"

namespace routeguide::v1 {

namespace RouteGuideNS {
template <typename R>
class UnimplementedClientReader final: public grpc::ClientReaderInterface<R> {
 public:
  void WaitForInitialMetadata() override {}
  bool NextMessageSize(uint32_t* sz) override { return true; }
  bool Read(R* msg) override { return false; }
  grpc::Status Finish() override { return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "Please call non-streaming method instead"); }
};

GetFeatureAPI::GetFeatureAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider) {
  mStub = routeguide::v1::RouteGuide::NewStub(provider->ConnectionChannel());
}

std::string GetFeatureAPI::Name() {
  return "routeguide_v1_RouteGuide_GetFeature";
}

std::string GetFeatureAPI::ServiceName() {
  return kServiceName;
}

std::string GetFeatureAPI::MethodName() {
  return "GetFeature";
}

grpc::Status GetFeatureAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Point& request,
  routeguide::v1::Feature* response) const {
  return mStub->GetFeature(context, request, response);
}

std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> GetFeatureAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Point& request) const {
  return std::make_unique<UnimplementedClientReader<routeguide::v1::Feature>>();
}

UpdateFeatureAPI::UpdateFeatureAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider) {
  mStub = routeguide::v1::RouteGuide::NewStub(provider->ConnectionChannel());
}

std::string UpdateFeatureAPI::Name() {
  return "routeguide_v1_RouteGuide_UpdateFeature";
}

std::string UpdateFeatureAPI::ServiceName() {
  return kServiceName;
}

std::string UpdateFeatureAPI::MethodName() {
  return "UpdateFeature";
}

grpc::Status UpdateFeatureAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Point& request,
  routeguide::v1::Feature* response) const {
  return mStub->UpdateFeature(context, request, response);
}

std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> UpdateFeatureAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Point& request) const {
  return std::make_unique<UnimplementedClientReader<routeguide::v1::Feature>>();
}

ListFeaturesAPI::ListFeaturesAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider) {
  mStub = routeguide::v1::RouteGuide::NewStub(provider->ConnectionChannel());
}

std::string ListFeaturesAPI::Name() {
  return "routeguide_v1_RouteGuide_ListFeatures";
}

std::string ListFeaturesAPI::ServiceName() {
  return kServiceName;
}

std::string ListFeaturesAPI::MethodName() {
  return "ListFeatures";
}

grpc::Status ListFeaturesAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Rectangle& request,
  routeguide::v1::Feature* response) const {
  return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "Please call streaming method instead");
}

std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> ListFeaturesAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Rectangle& request) const {
  return mStub->ListFeatures(context, request);
}

grpc::Status Invoke(const std::shared_ptr<crux::engine::ChannelProvider>& provider, grpc::ClientContext* context, const google::protobuf::Any& request_data, const std::string& method_name) {
  if (method_name == "GetFeature") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    GetFeatureAPI api = GetFeatureAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "UpdateFeature") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    UpdateFeatureAPI api = UpdateFeatureAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "ListFeatures") {
    routeguide::v1::Rectangle request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    ListFeaturesAPI api = ListFeaturesAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "RecordRoute") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    RecordRouteAPI api = RecordRouteAPI(provider);
    routeguide::v1::RouteSummary response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "RouteChat") {
    routeguide::v1::RouteNote request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    RouteChatAPI api = RouteChatAPI(provider);
    routeguide::v1::RouteNote response;
    return api.Execute(context, request, &response);
  }

  return grpc::Status(grpc::StatusCode::DATA_LOSS, "Invalid method name");
}

}  // namespace RouteGuideNS

namespace PublicRouteGuideNS {
template <typename R>
class UnimplementedClientReader final: public grpc::ClientReaderInterface<R> {
 public:
  void WaitForInitialMetadata() override {}
  bool NextMessageSize(uint32_t* sz) override { return true; }
  bool Read(R* msg) override { return false; }
  grpc::Status Finish() override { return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "Please call non-streaming method instead"); }
};

GetFeatureAPI::GetFeatureAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider) {
  mStub = routeguide::v1::PublicRouteGuide::NewStub(provider->ConnectionChannel());
}

std::string GetFeatureAPI::Name() {
  return "routeguide_v1_PublicRouteGuide_GetFeature";
}

std::string GetFeatureAPI::ServiceName() {
  return kServiceName;
}

std::string GetFeatureAPI::MethodName() {
  return "GetFeature";
}

grpc::Status GetFeatureAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Point& request,
  routeguide::v1::Feature* response) const {
  return mStub->GetFeature(context, request, response);
}

std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> GetFeatureAPI::Execute(
  grpc::ClientContext* context,
  const routeguide::v1::Point& request) const {
  return std::make_unique<UnimplementedClientReader<routeguide::v1::Feature>>();
}

grpc::Status Invoke(const std::shared_ptr<crux::engine::ChannelProvider>& provider, grpc::ClientContext* context, const google::protobuf::Any& request_data, const std::string& method_name) {
  if (method_name == "GetFeature") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    GetFeatureAPI api = GetFeatureAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  return grpc::Status(grpc::StatusCode::DATA_LOSS, "Invalid method name");
}

}  // namespace PublicRouteGuideNS


}  // namespace routeguide::v1

