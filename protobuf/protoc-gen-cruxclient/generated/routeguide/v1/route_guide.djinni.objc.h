// This file is generated by s12-proto api generator. Please DO NOT modify.
#pragma once
#include <string>
#include "routeguide/v1/message.pb.h"
#import "routeguide_v1_Message.pbobjc.h"

namespace djinni::routeguide::v1::Point {
struct Translator {
  using CppType = ::routeguide::v1::Point;
  using ObjcType = RTGPoint*;
  using Boxed = Translator;

  static CppType toCpp(ObjcType message) {
    assert(message);
    NSData * data = [message data];
    const void *bytes = [data bytes];
    int byte_len = (int)[data length];
    CppType cpp_message;
    cpp_message.ParseFromArray(bytes, byte_len);
    return cpp_message;
  }

  static ObjcType fromCpp(const CppType& message) {
    size_t byte_size = message.ByteSizeLong();
    void *bytes = malloc(byte_size);
    message.SerializeToArray(bytes, static_cast<int>(byte_size));
    NSData *data = [NSData dataWithBytes: bytes length: (int)byte_size];
    NSError *error;
    return [RTGPoint parseFromData:data error:&error];
  }
};
}  //namespace djinni::routeguide::v1::Point

#include "routeguide/v1/message.pb.h"
#import "routeguide_v1_Message.pbobjc.h"

namespace djinni::routeguide::v1::Rectangle {
struct Translator {
  using CppType = ::routeguide::v1::Rectangle;
  using ObjcType = RTGRectangle*;
  using Boxed = Translator;

  static CppType toCpp(ObjcType message) {
    assert(message);
    NSData * data = [message data];
    const void *bytes = [data bytes];
    int byte_len = (int)[data length];
    CppType cpp_message;
    cpp_message.ParseFromArray(bytes, byte_len);
    return cpp_message;
  }

  static ObjcType fromCpp(const CppType& message) {
    size_t byte_size = message.ByteSizeLong();
    void *bytes = malloc(byte_size);
    message.SerializeToArray(bytes, static_cast<int>(byte_size));
    NSData *data = [NSData dataWithBytes: bytes length: (int)byte_size];
    NSError *error;
    return [RTGRectangle parseFromData:data error:&error];
  }
};
}  //namespace djinni::routeguide::v1::Rectangle

#include "routeguide/v1/message.pb.h"
#import "routeguide_v1_Message.pbobjc.h"

namespace djinni::routeguide::v1::Feature {
struct Translator {
  using CppType = ::routeguide::v1::Feature;
  using ObjcType = RTGFeature*;
  using Boxed = Translator;

  static CppType toCpp(ObjcType message) {
    assert(message);
    NSData * data = [message data];
    const void *bytes = [data bytes];
    int byte_len = (int)[data length];
    CppType cpp_message;
    cpp_message.ParseFromArray(bytes, byte_len);
    return cpp_message;
  }

  static ObjcType fromCpp(const CppType& message) {
    size_t byte_size = message.ByteSizeLong();
    void *bytes = malloc(byte_size);
    message.SerializeToArray(bytes, static_cast<int>(byte_size));
    NSData *data = [NSData dataWithBytes: bytes length: (int)byte_size];
    NSError *error;
    return [RTGFeature parseFromData:data error:&error];
  }
};
}  //namespace djinni::routeguide::v1::Feature

#include "routeguide/v1/message.pb.h"
#import "routeguide_v1_Message.pbobjc.h"

namespace djinni::routeguide::v1::RouteNote {
struct Translator {
  using CppType = ::routeguide::v1::RouteNote;
  using ObjcType = RTGRouteNote*;
  using Boxed = Translator;

  static CppType toCpp(ObjcType message) {
    assert(message);
    NSData * data = [message data];
    const void *bytes = [data bytes];
    int byte_len = (int)[data length];
    CppType cpp_message;
    cpp_message.ParseFromArray(bytes, byte_len);
    return cpp_message;
  }

  static ObjcType fromCpp(const CppType& message) {
    size_t byte_size = message.ByteSizeLong();
    void *bytes = malloc(byte_size);
    message.SerializeToArray(bytes, static_cast<int>(byte_size));
    NSData *data = [NSData dataWithBytes: bytes length: (int)byte_size];
    NSError *error;
    return [RTGRouteNote parseFromData:data error:&error];
  }
};
}  //namespace djinni::routeguide::v1::RouteNote

#include "routeguide/v1/message.pb.h"
#import "routeguide_v1_Message.pbobjc.h"

namespace djinni::routeguide::v1::RouteSummary {
struct Translator {
  using CppType = ::routeguide::v1::RouteSummary;
  using ObjcType = RTGRouteSummary*;
  using Boxed = Translator;

  static CppType toCpp(ObjcType message) {
    assert(message);
    NSData * data = [message data];
    const void *bytes = [data bytes];
    int byte_len = (int)[data length];
    CppType cpp_message;
    cpp_message.ParseFromArray(bytes, byte_len);
    return cpp_message;
  }

  static ObjcType fromCpp(const CppType& message) {
    size_t byte_size = message.ByteSizeLong();
    void *bytes = malloc(byte_size);
    message.SerializeToArray(bytes, static_cast<int>(byte_size));
    NSData *data = [NSData dataWithBytes: bytes length: (int)byte_size];
    NSError *error;
    return [RTGRouteSummary parseFromData:data error:&error];
  }
};
}  //namespace djinni::routeguide::v1::RouteSummary

