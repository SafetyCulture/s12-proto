// Copyright (c) 2020 SafetyCulture Pty Ltd. All Rights Reserved.
#include "api_generator.h"
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/compiler/plugin.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <iostream>
#include <vector>
#include <map>
#include <memory>
#include "common.h"

using google::protobuf::Descriptor;
using google::protobuf::FileDescriptor;
using google::protobuf::MethodDescriptor;
using google::protobuf::ServiceDescriptor;
using google::protobuf::compiler::CodeGenerator;
using google::protobuf::compiler::GeneratorContext;
using google::protobuf::compiler::ParseGeneratorParameter;
using google::protobuf::compiler::PluginMain;
using google::protobuf::io::Printer;
using google::protobuf::io::ZeroCopyOutputStream;
using std::string;

namespace cruxclient_generator {

void APIGenerator::PrintPrologue(
  Printer *printer,
  const FileDescriptor *file) const {
  std::map<string, string> vars;
  vars["filename"] = file->name();
  printer->Print("// Generated by the CRUX Engine C++ plugin.\n");
  printer->Print("// If you make any local change, they will be lost.\n");
  printer->Print(vars, "// source: $filename$\n");
}

void APIGenerator::PrintNamespace(
  Printer *printer,
  const FileDescriptor *file,
  bool isEpilogue) const {
  std::map<string, string> vars;
  if (!file->package().empty()) {
    vars["namespace"] = DotsToColons(file->package());

    if (!isEpilogue) {
      printer->Print(vars, "namespace $namespace$ {\n");
    } else {
      printer->Print(vars, "}  // namespace $namespace$\n");
    }
    printer->Print(vars, "\n");
  }
}

void APIGenerator::PrintHeaderPrologue(
  Printer *printer,
  const FileDescriptor *file) const {
  std::map<string, string> vars;
  vars["filename_identifier"] = FilenameIdentifier(file->name());

  PrintPrologue(printer, file);
}

void APIGenerator::PrintHeaderIncludes(
  Printer *printer,
  const FileDescriptor *file) const {
  std::map<string, string> vars;
  vars["filename_base"] = StripProto(file->name());
  auto package_name = file->package();
  ReplaceCharacters(&package_name, ".", '/');

  printer->Print("#pragma once\n\n");
  printer->Print("#include <vector>\n");
  printer->Print("#include <string>\n");
  printer->Print("#include <memory>\n\n");
  printer->Print(vars, "#include <google/protobuf/any.pb.h>\n");
  printer->Print(vars, "#include \"$filename_base$.grpc.pb.h\"\n");
  printer->Print(vars, "#include \"crux_engine_client_support.h\"\n\n");

  PrintNamespace(printer, file, false);
}

void APIGenerator::PrintHeaderAPIs(
  Printer *printer,
  const FileDescriptor *file) const {
  std::map<string, string> vars;

  for (int service_index = 0; service_index < file->service_count();
       ++service_index) {
    const ServiceDescriptor *service = file->service(service_index);
    vars["service_name"] = service->name();
    vars["service_fullname"] = DotsToColons(service->full_name());

    printer->Print(vars, "namespace $service_name$NS {\n");

    for (int method_index = 0; method_index < service->method_count();
        ++method_index) {
      const MethodDescriptor *method = service->method(method_index);
      vars["method_name"] = method->name();
      vars["request"] = ClassName(method->input_type(), true);
      vars["response"] = ClassName(method->output_type(), true);
      vars["api_name"] = method->name() + "API";

      if (method->client_streaming()) {
        // [RC]: Client Steaming not supported yet
        continue;
      }

      printer->Print(vars, "class $api_name$ {\n");
      printer->Print(" public:\n");
      printer->Indent();
      printer->Print(vars,
      "explicit $api_name$(const std::shared_ptr<crux::engine::ChannelProvider>& provider);\n");
      printer->Print("static std::string Name();\n");
      printer->Print("static std::string ServiceName();\n");
      printer->Print("static std::string MethodName();\n");
      printer->Print(vars, "grpc::Status Execute(\n");
      printer->Indent();
      printer->Print(vars, "grpc::ClientContext* context,\n"
        "const $request$& request,\n"
        "$response$* response) const;\n");
      printer->Outdent();
      printer->Print("// server streaming\n");
      printer->Print(vars, "std::unique_ptr<grpc::ClientReaderInterface<$response$>> Execute(\n");
      printer->Indent();
      printer->Print(vars, "grpc::ClientContext* context,\n"
        "const $request$& request) const;\n");
      printer->Outdent();
      printer->Outdent();
      printer->Print(" private:\n");
      printer->Indent();
      printer->Print(vars, "std::unique_ptr<$service_name$::StubInterface> mStub;\n");
      printer->Outdent();
      printer->Print("};\n\n");
    }

    printer->Print("template<typename RESPONSE>\n");
    printer->Print("grpc::Status Invoke("
    "const std::shared_ptr<crux::engine::ChannelProvider>& provider, "
    "grpc::ClientContext* context, "
    "const google::protobuf::Any& request_data, "
    "const std::string& method_name) {\n");
    printer->Indent();
    for (int method_index = 0; method_index < service->method_count();
        ++method_index) {
      const MethodDescriptor *method = service->method(method_index);
      vars["method_name"] = method->name();
      vars["request"] = ClassName(method->input_type(), true);
      vars["response"] = ClassName(method->output_type(), true);
      vars["api_name"] = method->name() + "API";

      printer->Print(vars, "if (method_name == \"$method_name$\") {\n");
      printer->Indent();
      printer->Print(vars, "$request$ request;\n");
      printer->Print("if (!request_data.UnpackTo(&request)) {\n");
      printer->Indent();
      printer->Print("return grpc::Status(grpc::StatusCode::DATA_LOSS, \"Unable to unpack the request data\");\n");
      printer->Outdent();
      printer->Print("}\n");
      printer->Print(vars, "$api_name$ api = $api_name$(provider);\n");
      printer->Print(vars, "$response$ response;\n");
      printer->Print("return api.Execute(context, request, &response);\n");
      printer->Outdent();
      printer->Print("}\n\n");
    }
    printer->Print("return grpc::Status(grpc::StatusCode::DATA_LOSS, \"Invalid method name\");\n");
    printer->Outdent();
    printer->Print("}\n\n");

    printer->Print(vars, "}  // namespace $service_name$NS\n\n");
  }
}

void APIGenerator::PrintHeaderEpilogue(
  Printer *printer,
  const FileDescriptor *file) const {
  PrintNamespace(printer, file, true);
}

void APIGenerator::PrintSourcePrologue(
  Printer *printer,
  const FileDescriptor *file) const {
  PrintPrologue(printer, file);
  printer->Print("\n");
}

void APIGenerator::PrintSourceIncludes(
  Printer *printer,
  const FileDescriptor *file) const {
  std::map<string, string> vars;
  vars["filename_base"] = tokenize(StripProto(file->name()), "/").back();
  printer->Print(vars, "#include \"$filename_base$.crux.api.h\"\n\n");

  PrintNamespace(printer, file, false);
}

void APIGenerator::PrintSourceAPIs(
  Printer *printer,
  const FileDescriptor *file) const {
  std::map<string, string> vars;

  for (int service_index = 0; service_index < file->service_count();
       ++service_index) {
    const ServiceDescriptor *service = file->service(service_index);
    vars["service_name"] = service->name();
    vars["service_fullname"] = DotsToColons(service->full_name());
    vars["service_fullname_underscore"] = DotsToUnderscores(service->full_name());

    printer->Print(vars, "namespace $service_name$NS {\n");
    printer->Print("template <typename R>\n");
    printer->Print("class UnimplementedClientReader final: public grpc::ClientReaderInterface<R> {\n");
    printer->Print(" public:\n");
    printer->Indent();
    printer->Print("void WaitForInitialMetadata() override {}\n");
    printer->Print("bool NextMessageSize(uint32_t* sz) override { return true; }\n");
    printer->Print("bool Read(R* msg) override { return false; }\n");
    printer->Print("grpc::Status Finish() override { return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, \"Please call non-streaming method instead\"); }\n");
    printer->Outdent();
    printer->Print("};\n\n");
    for (int method_index = 0; method_index < service->method_count();
         ++method_index) {
      const MethodDescriptor *method = service->method(method_index);
      vars["method_name"] = method->name();
      vars["request"] = ClassName(method->input_type(), true);
      vars["response"] = ClassName(method->output_type(), true);
      vars["api_name"] = method->name() + "API";

      if (method->client_streaming()) {
        // [RC]: Client Streaming not supported... yet
        continue;
      }

      printer->Print(vars,
      "$api_name$::$api_name$(const std::shared_ptr<crux::engine::ChannelProvider>& provider) {\n");
      printer->Indent();
      printer->Print(vars, "mStub = $service_fullname$::NewStub(provider->ConnectionChannel());\n");
      printer->Outdent();
      printer->Print("}\n\n");

      printer->Print(vars, "std::string $api_name$::Name() {\n");
      printer->Indent();
      printer->Print(vars, "return \"$service_fullname_underscore$_$method_name$\";\n");
      printer->Outdent();
      printer->Print("}\n\n");

      printer->Print(vars, "std::string $api_name$::ServiceName() {\n");
      printer->Indent();
      printer->Print(vars, "return \"$service_fullname_underscore$\";\n");
      printer->Outdent();
      printer->Print("}\n\n");

      printer->Print(vars, "std::string $api_name$::MethodName() {\n");
      printer->Indent();
      printer->Print(vars, "return \"$method_name$\";\n");
      printer->Outdent();
      printer->Print("}\n\n");

      printer->Print(vars, "grpc::Status $api_name$::Execute(\n");
      printer->Indent();
      printer->Print(vars, "grpc::ClientContext* context,\n"
        "const $request$& request,\n"
        "$response$* response) const {\n");
      if (method->server_streaming()) {
        printer->Print(vars, "return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, \"Please call streaming method instead\");\n");
      } else {
        printer->Print(vars, "return mStub->$method_name$(context, request, response);\n");
      }
      printer->Outdent();
      printer->Print("}\n\n");

      printer->Print(vars, "std::unique_ptr<grpc::ClientReaderInterface<$response$>> $api_name$::Execute(\n");
      printer->Indent();
      printer->Print(vars, "grpc::ClientContext* context,\n"
        "const $request$& request) const {\n");
      if (method->server_streaming()) {
        printer->Print(vars, "return mStub->$method_name$(context, request);\n");
      } else {
        printer->Print(vars, "return std::make_unique<UnimplementedClientReader<$response$>>();\n");
      }
      printer->Outdent();
      printer->Print("}\n\n");
    }
    printer->Print(vars, "}  // namespace $service_name$NS\n\n");
  }
}

void APIGenerator::PrintSourceEpilogue(
  Printer *printer,
  const FileDescriptor *file) const {
  printer->Print("\n");
  PrintNamespace(printer, file, true);
}

void APIGenerator::GenerateAPIHeader(
  const google::protobuf::FileDescriptor *file,
  const std::string &parameter,
  google::protobuf::compiler::GeneratorContext *context) const {
  string file_name = StripProto(file->name());
  std::unique_ptr<ZeroCopyOutputStream> output(
      context->Open(file_name + ".crux.api.h"));
  Printer printer(output.get(), '$');
  PrintHeaderPrologue(&printer, file);
  PrintHeaderIncludes(&printer, file);
  PrintHeaderAPIs(&printer, file);
  PrintHeaderEpilogue(&printer, file);
}

void APIGenerator::GenerateAPISource(
  const google::protobuf::FileDescriptor *file,
  const std::string &parameter,
  google::protobuf::compiler::GeneratorContext *context) const {
  string file_name = StripProto(file->name());
  std::unique_ptr<ZeroCopyOutputStream> output(
      context->Open(file_name + ".crux.api.cc"));
  Printer printer(output.get(), '$');
  PrintSourcePrologue(&printer, file);
  PrintSourceIncludes(&printer, file);
  PrintSourceAPIs(&printer, file);
  PrintSourceEpilogue(&printer, file);
}

void APIGenerator::Generate(
  const google::protobuf::FileDescriptor *file,
  const std::string &parameter,
  google::protobuf::compiler::GeneratorContext *context,
  std::string *error) const {
  GenerateAPIHeader(file, parameter, context);
  GenerateAPISource(file, parameter, context);
}
}  // namespace cruxclient_generator
