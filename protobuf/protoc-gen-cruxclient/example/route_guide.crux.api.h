// Generated by the CRUX Engine C++ plugin.
// If you make any local change, they will be lost.
// source: route_guide.proto
#pragma once

#include <vector>
#include <string>
#include <memory>

#include <google/protobuf/any.pb.h>
#include "route_guide.grpc.pb.h"
#include "crux_engine_client_support.h"

namespace routeguide::v1 {

namespace RouteGuideNS {
class GetFeatureAPI {
 public:
  explicit GetFeatureAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider);
  static std::string Name();
  static std::string ServiceName();
  static std::string MethodName();
  grpc::Status Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Point& request,
    routeguide::v1::Feature* response) const;
  // server streaming
  std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Point& request) const;
 private:
  std::unique_ptr<RouteGuide::StubInterface> mStub;
};

class UpdateFeatureAPI {
 public:
  explicit UpdateFeatureAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider);
  static std::string Name();
  static std::string ServiceName();
  static std::string MethodName();
  grpc::Status Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Point& request,
    routeguide::v1::Feature* response) const;
  // server streaming
  std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Point& request) const;
 private:
  std::unique_ptr<RouteGuide::StubInterface> mStub;
};

class ListFeaturesAPI {
 public:
  explicit ListFeaturesAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider);
  static std::string Name();
  static std::string ServiceName();
  static std::string MethodName();
  grpc::Status Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Rectangle& request,
    routeguide::v1::Feature* response) const;
  // server streaming
  std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Rectangle& request) const;
 private:
  std::unique_ptr<RouteGuide::StubInterface> mStub;
};

template<typename RESPONSE>
grpc::Status Invoke(const std::shared_ptr<crux::engine::ChannelProvider>& provider, grpc::ClientContext* context, const google::protobuf::Any& request_data, const std::string& method_name) {
  if (method_name == "GetFeature") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    GetFeatureAPI api = GetFeatureAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "UpdateFeature") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    UpdateFeatureAPI api = UpdateFeatureAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "ListFeatures") {
    routeguide::v1::Rectangle request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    ListFeaturesAPI api = ListFeaturesAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "RecordRoute") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    RecordRouteAPI api = RecordRouteAPI(provider);
    routeguide::v1::RouteSummary response;
    return api.Execute(context, request, &response);
  }

  if (method_name == "RouteChat") {
    routeguide::v1::RouteNote request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    RouteChatAPI api = RouteChatAPI(provider);
    routeguide::v1::RouteNote response;
    return api.Execute(context, request, &response);
  }

  return grpc::Status(grpc::StatusCode::DATA_LOSS, "Invalid method name");
}

}  // namespace RouteGuideNS

namespace PublicRouteGuideNS {
class GetFeatureAPI {
 public:
  explicit GetFeatureAPI(const std::shared_ptr<crux::engine::ChannelProvider>& provider);
  static std::string Name();
  static std::string ServiceName();
  static std::string MethodName();
  grpc::Status Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Point& request,
    routeguide::v1::Feature* response) const;
  // server streaming
  std::unique_ptr<grpc::ClientReaderInterface<routeguide::v1::Feature>> Execute(
    grpc::ClientContext* context,
    const routeguide::v1::Point& request) const;
 private:
  std::unique_ptr<PublicRouteGuide::StubInterface> mStub;
};

template<typename RESPONSE>
grpc::Status Invoke(const std::shared_ptr<crux::engine::ChannelProvider>& provider, grpc::ClientContext* context, const google::protobuf::Any& request_data, const std::string& method_name) {
  if (method_name == "GetFeature") {
    routeguide::v1::Point request;
    if (!request_data.UnpackTo(&request)) {
      return grpc::Status(grpc::StatusCode::DATA_LOSS, "Unable to unpack the request data");
    }
    GetFeatureAPI api = GetFeatureAPI(provider);
    routeguide::v1::Feature response;
    return api.Execute(context, request, &response);
  }

  return grpc::Status(grpc::StatusCode::DATA_LOSS, "Invalid method name");
}

}  // namespace PublicRouteGuideNS

}  // namespace routeguide::v1
